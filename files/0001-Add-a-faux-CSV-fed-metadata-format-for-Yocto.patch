From 7db12f132f8f8dc99bb6ddd95e9606be3789668d Mon Sep 17 00:00:00 2001
From: Ikey Doherty <michael.i.doherty@intel.com>
Date: Fri, 26 Jun 2015 14:18:31 +0100
Subject: [PATCH 01/13] Add a "faux", CSV-fed, metadata format for Yocto

This enables the tool to be fed pregenerated data from prior runs, for
systems where it is not feasible to add direct source scanning support, such
as Yocto's layered bitbake system.

This enables support for issue #16

Signed-off-by: Ikey Doherty <michael.i.doherty@intel.com>
---
 src/Makefile.am      |   2 +
 src/library/common.h |   1 +
 src/library/util.c   |   4 ++
 src/library/util.h   |  13 ++++++
 src/main.c           | 109 ++++++++++++++++++++++++++++++++++++++++++++++++++-
 src/packaging/faux.c |  59 ++++++++++++++++++++++++++++
 src/packaging/faux.h |  24 ++++++++++++
 7 files changed, 210 insertions(+), 2 deletions(-)
 create mode 100644 src/packaging/faux.c
 create mode 100644 src/packaging/faux.h

diff --git a/src/Makefile.am b/src/Makefile.am
index d96896a..8661e78 100644
--- a/src/Makefile.am
+++ b/src/Makefile.am
@@ -26,6 +26,8 @@ libcve_la_SOURCES = \
 	packaging/eopkg.h \
 	packaging/rpm.h \
 	packaging/rpm.c \
+	packaging/faux.h \
+	packaging/faux.c \
 	packaging/pkgbuild.h \
 	packaging/pkgbuild.c \
 	core.h \
diff --git a/src/library/common.h b/src/library/common.h
index 83eee4f..da03c3a 100644
--- a/src/library/common.h
+++ b/src/library/common.h
@@ -60,6 +60,7 @@ typedef enum {
         PACKAGE_TYPE_SRPM,      /**<SRPM package */
         PACKAGE_TYPE_EOPKG,     /**<EOPKG package */
         PACKAGE_TYPE_PKGBUILD,  /**<PKGBUILD (Arch) package */
+        PACKAGE_TYPE_FAUX,      /**<Forced CSV input */
         PACKAGE_TYPE_UNKNOWN,   /**<Unknown package type */
         PACKAGE_TYPE_MAX
 } PackageType;
diff --git a/src/library/util.c b/src/library/util.c
index 671b177..3d55dbb 100644
--- a/src/library/util.c
+++ b/src/library/util.c
@@ -102,6 +102,8 @@ PackageType guess_package_type(gchar *path, bool recurse)
                         type = PACKAGE_TYPE_RPM;
                 } else if (pkgbuild_is_package(p)) {
                         type = PACKAGE_TYPE_PKGBUILD;
+                } else if (faux_is_package(p)) {
+                        type = PACKAGE_TYPE_FAUX;
                 }
                 goto end;
         } else if (S_ISDIR(st.st_mode) && recurse) {
@@ -133,6 +135,8 @@ PackageType guess_package_type(gchar *path, bool recurse)
                         } else if (pkgbuild_is_package(cp)) {
                                 type = PACKAGE_TYPE_PKGBUILD;
                                 break;
+                        } else if (faux_is_package(cp)) {
+                                type = PACKAGE_TYPE_FAUX;
                         }
                 }
         }
diff --git a/src/library/util.h b/src/library/util.h
index a26d039..69ae1fa 100644
--- a/src/library/util.h
+++ b/src/library/util.h
@@ -26,6 +26,8 @@
 #include "cve-check-tool.h"
 #include "cve-string.h"
 
+#include "faux.h"
+
 /**
  * Attempt to guess the package type from the path
  *
@@ -207,6 +209,8 @@ static inline void package_free(void *p)
                 return;
         }
         struct source_package_t *t = p;
+        struct FauxData *d = NULL;
+
         if (t->issues) { /* bless you */
                 g_list_free_full(t->issues, xmlFree);
         }
@@ -231,6 +235,15 @@ static inline void package_free(void *p)
                 case PACKAGE_TYPE_RPM:
                         g_list_free_full(t->extra, g_free);
                         break;
+                case PACKAGE_TYPE_FAUX:
+                        d = t->extra;
+                        if (d->patched) {
+                                g_strfreev(d->patched);
+                        }
+                        if (d->ignored) {
+                                g_strfreev(d->ignored);
+                        }
+                        free(d);
                 default:
                         break;
                 }
diff --git a/src/main.c b/src/main.c
index 2399d19..a174c85 100644
--- a/src/main.c
+++ b/src/main.c
@@ -27,6 +27,7 @@
 #include "eopkg.h"
 #include "rpm.h"
 #include "pkgbuild.h"
+#include "faux.h"
 #include "util.h"
 #include "plugins/jira/jira.h"
 #include "config.h"
@@ -44,7 +45,7 @@ static char *srpm_dir = NULL;
 #define DEFAULT_CONFIG_FILE     DEFAULT_PATH    "/cve-check-tool.conf"
 #define SITE_CONFIG_FILE        SITE_PATH       "/cve-check-tool.conf"
 
-#define SUPPORTED_TYPES "eopkg, rpm, pkgbuild"
+#define SUPPORTED_TYPES "eopkg, rpm, pkgbuild, faux"
 
 DEF_AUTOFREE(char, free)
 
@@ -103,9 +104,107 @@ insert:
         g_hash_table_insert(self->db, pkg->name, pkg);
 }
 
+/**
+ * Load CSV data, "faux" as this is metadata, not generated from scanned source
+ * files.
+ */
+static bool load_faux(const char *path)
+{
+        FILE *fp = NULL;
+        size_t read = -1;
+        size_t buf_size = 0;
+        char *buf = NULL;
+        bool ret = false;
+        int line = 1;
+
+        fp = fopen(path, "r");
+        if (!fp) {
+                fprintf(stderr, "load_faux(): %s\n", strerror(errno));
+                goto end;
+        }
+
+        while ((read = getline(&buf, &buf_size, fp) > 0)) {
+                /* TODO: Use a dedicated CsvParser */
+                autofree(gstrv) *strv = NULL;
+                struct source_package_t *t = NULL;
+                struct FauxData *d = NULL;
+                gint len;
+
+                buf = g_strchomp(buf);
+                /* Empty line */
+                if (streq(buf, "")) {
+                        goto next;
+                }
+
+                strv = g_strsplit(buf, ",", 4);
+                if ((len = g_strv_length(strv)) != 4) {
+                        fprintf(stderr, "Line #%d is of incorrect length\n", line);
+                        break;
+                }
+
+                strv[0] = g_strchomp(strv[0]);
+                strv[1] = g_strchomp(strv[1]);
+                strv[2] = g_strchomp(strv[2]);
+                strv[3] = g_strchomp(strv[3]);
+
+                if (streq(strv[0], "")) {
+                        fprintf(stderr, "Line #%d: Package name cannot be empty\n", line);
+                        break;
+                }
+                if (streq(strv[1], "")) {
+                        fprintf(stderr, "Line #%d: Package version cannot be empty\n", line);
+                        break;
+                }
+
+                t = calloc(1, sizeof(struct source_package_t));
+                if (!t) {
+                        fprintf(stderr, "Out of memory\n");
+                        free(buf);
+                        exit(-1);
+                }
+
+                d = calloc(1, sizeof(struct FauxData));
+                if (!d) {
+                        fprintf(stderr, "Out of memory\n");
+                        free(t);
+                        free(buf);
+                        exit(-1);
+                }
+
+                t->name = g_strdup(strv[0]);
+                t->version = g_strdup(strv[1]);
+                if (!streq(strv[2], "")) {
+                        d->patched = g_strsplit(strv[2], " ", -1);
+                }
+                if (!streq(strv[3], "")) {
+                        d->ignored = g_strsplit(strv[3], " ", -1);
+                }
+                t->extra = d;
+
+                cve_add_package_internal(t);
+next:
+                free(buf);
+                buf = NULL;
+                ++line;
+        }
+        if (read) {
+                free(buf);
+                buf = NULL;
+        }
+end:
+        return ret;
+}
+
 void cve_add_package(const char *path)
 {
-        struct source_package_t *pkg = self->examine(path);
+        struct source_package_t *pkg = NULL;
+
+        if (self->examine) {
+                pkg = self->examine(path);
+        } else {
+                /* only possible for faux */
+                load_faux(path);
+        }
         if (!pkg) {
                 return;
         }
@@ -172,6 +271,10 @@ static bool set_package_type(PackageType type)
                         self->is_patched = &pkgbuild_is_patched;
                         self->locate = &pkgbuild_locate_sources;
                         return true;
+                case PACKAGE_TYPE_FAUX:
+                        self->is_patched = &faux_is_patched;
+                        self->is_ignored = &faux_is_ignored;
+                        return true;
                 default:
                         return false;
         }
@@ -375,6 +478,8 @@ int main(int argc, char **argv)
                         type = PACKAGE_TYPE_EOPKG;
                 } else if (g_str_equal(forced_type, "pkgbuild")) {
                         type = PACKAGE_TYPE_PKGBUILD;
+                } else if (g_str_equal(forced_type, "faux")) {
+                        type = PACKAGE_TYPE_FAUX;
                 } else if (g_str_equal(forced_type, "list")) {
                         fprintf(stderr, "Currently supported package types: %s\n", SUPPORTED_TYPES);
                         ret = EXIT_SUCCESS;
diff --git a/src/packaging/faux.c b/src/packaging/faux.c
new file mode 100644
index 0000000..0643576
--- /dev/null
+++ b/src/packaging/faux.c
@@ -0,0 +1,59 @@
+/*
+ * faux.c - Generic package support
+ *
+ * Copyright (C) 2015 Intel Corporation
+ *
+ * cve-check-tool is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+#define _GNU_SOURCE
+#include <glib.h>
+
+#include "faux.h"
+#include "util.h"
+#include "cve-check-tool.h"
+
+bool faux_patch_check(struct source_package_t *t, char *id, bool ignore)
+{
+        struct FauxData *d = NULL;
+        gchar **list = NULL;
+
+        if (!t->extra) {
+                return false;
+        }
+
+        d = t->extra;
+        list = ignore ? d->ignored : d->patched;
+        if (!list) {
+                return false;
+        }
+
+        for (uint i = 0; i < g_strv_length(list); i++) {
+                list[i] = g_strchomp(list[i]);
+                if (g_str_equal(list[i], "")) {
+                        continue;
+                }
+                if (g_str_equal(id, list[i])) {
+                        return true;
+                }
+        }
+
+        return false;
+}
+
+bool faux_is_patched(struct source_package_t *t, char *id)
+{
+        return faux_patch_check(t, id, false);
+}
+
+bool faux_is_ignored(struct source_package_t *t, char *id)
+{
+        return faux_patch_check(t, id, true);
+}
+
+bool faux_is_package(const char *filename)
+{
+        return g_str_has_suffix((const gchar*)filename, ".csv");
+}
diff --git a/src/packaging/faux.h b/src/packaging/faux.h
new file mode 100644
index 0000000..a564705
--- /dev/null
+++ b/src/packaging/faux.h
@@ -0,0 +1,24 @@
+/*
+ * faux.h
+ *
+ * Copyright (C) 2015 Intel Corporation
+ *
+ * cve-check-tool is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+
+#pragma once
+
+#include "cve-check-tool.h"
+
+struct FauxData {
+        gchar **patched;
+        gchar **ignored;
+};
+
+bool faux_is_patched(struct source_package_t *pkg, char *id);
+bool faux_is_ignored(struct source_package_t *pkg, char *id);
+
+bool faux_is_package(const char *filename);
-- 
2.4.6

